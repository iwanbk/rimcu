package rimcu

import (
	"context"
	"errors"

	"github.com/gomodule/redigo/redis"
	"github.com/iwanbk/rimcu/internal/inmemcache"
	"github.com/iwanbk/rimcu/internal/inmemcache/keycache"
	"github.com/iwanbk/rimcu/internal/inmemcache/slotcache"
	"github.com/rs/xid"
)

const (
	notifChannel = "rimcu:set"
)

var (
	ErrNotFound = errors.New("not found")
)

// Client defines a rimcu client.
//
// Each client will have a unique name which currently is autogenerated.
//
// TODO generate name of the client using `CLIENT ID` redis commmand
type Client struct {
	pool *redis.Pool
	name []byte
	cc   inmemcache.Cache // in memory cache for the string data type

	// lua scripts
	luaSetex *redis.Script //setex command
	luaDel   *redis.Script // del command
}

// Config defines the configuration of the rimcu object
type Config struct {
	CacheSize     int
	StringBackend string
}

// NewWithPool creates new rimcu client with the given config and redigo pool
func NewWithPool(cfg Config, pool *redis.Pool) (*Client, error) {
	var (
		cc  inmemcache.Cache
		err error
	)
	if cfg.StringBackend == "slot " {
		cc, err = slotcache.New(cfg.CacheSize)
	} else {
		cc = keycache.New(cfg.CacheSize)
	}
	if err != nil {
		return nil, err
	}

	cli := &Client{
		name:     xid.New().Bytes(),
		pool:     pool,
		cc:       cc,
		luaSetex: redis.NewScript(1, scriptSetex),
		luaDel:   redis.NewScript(1, scriptDel),
	}
	err = cli.runSubscriber(context.TODO())
	return cli, err
}

// SetEx set the value of the key with the given value and expiration in second
func (c *Client) SetEx(ctx context.Context, key, val string, expSecond int) error {
	// get conn
	conn, err := c.pool.GetContext(ctx)
	if err != nil {
		return err
	}
	defer conn.Close()

	// set to redis
	notif, err := c.cc.NewNotif(c.name, key).Encode()
	if err != nil {
		return err
	}

	_, err = redis.String(c.luaSetex.Do(conn, key, expSecond, val, notif))
	if err != nil {
		return err
	}
	c.setMemCache(key, val, expSecond)
	return nil
}

// Get gets the value of the key.
//
// If the value not exists in the memory cache, it will try to get from the redis server
// and set the expiration to the given expSecond
func (c *Client) Get(ctx context.Context, key string, expSecond int) (string, error) {
	// try to get from in memory cache
	val, ok := c.getMemCache(key)
	if ok {
		return val, nil
	}

	// get from redis
	conn, err := c.pool.GetContext(ctx)
	if err != nil {
		return "", err
	}
	defer conn.Close()

	val, err = redis.String(conn.Do("GET", key))
	if err != nil {
		if err == redis.ErrNil {
			err = ErrNotFound
		}
		return "", err
	}

	// set to in-mem cache
	c.setMemCache(key, val, expSecond)

	return val, nil
}

func (c *Client) Del(ctx context.Context, key string) error {
	c.cc.Del(key)

	// get conn
	conn, err := c.pool.GetContext(ctx)
	if err != nil {
		return err
	}
	defer conn.Close()

	notif, err := c.cc.NewNotif(c.name, key).Encode()
	if err != nil {
		return err
	}
	_, err = redis.String(c.luaDel.Do(conn, key, notif))
	return err
}

func (c *Client) setMemCache(key, val string, expSecond int) {
	c.cc.SetEx(key, val, expSecond)
}

func (c *Client) getMemCache(key string) (string, bool) {
	return c.cc.Get(key)
}

const (
	scriptSetex = `
local setret = redis.call('setex', KEYS[1], ARGV[1], ARGV[2])
redis.call('publish', 'rimcu:set', ARGV[3])
return 'OK'
			`
	scriptDel = `
local setret = redis.call('del', KEYS[1])
redis.call('publish', 'rimcu:set', ARGV[1])
return '1'
			`
)
