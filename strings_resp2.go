package rimcu

import (
	"bytes"
	"context"
	"fmt"
	"log"

	"github.com/gomodule/redigo/redis"
	"github.com/iwanbk/rimcu/internal/inmemcache/keycache"
	"github.com/iwanbk/rimcu/internal/notif"
	"github.com/rs/xid"
)

// Each client will have a unique name which currently is autogenerated.
//
// TODO generate name of the client using `CLIENT ID` redis commmand
type StringsCacheResp2 struct {
	pool *redis.Pool
	name []byte
	cc   *keycache.KeyCache

	// context
	ctx        context.Context
	cancelFunc context.CancelFunc
	// lua scripts
	luaSetex *redis.Script //setex command
	luaDel   *redis.Script // del command
}

type StringsCacheResp2Config struct {
	CacheSize int
}

func NewStringsCacheResp2(cfg StringsCacheResp2Config, pool *redis.Pool) (*StringsCacheResp2, error) {
	var (
		ctx, cancel = context.WithCancel(context.Background())
	)

	cc, err := keycache.New(cfg.CacheSize)
	if err != nil {
		return nil, err
	}

	sc := &StringsCacheResp2{
		name:       xid.New().Bytes(),
		pool:       pool,
		cc:         cc,
		ctx:        ctx,
		cancelFunc: cancel,
		luaSetex:   redis.NewScript(1, scriptSetex),
		luaDel:     redis.NewScript(1, scriptDel),
	}
	return sc, sc.runSubscriber(context.TODO())
}

func (sc *StringsCacheResp2) Close() error {
	sc.cancelFunc()
	return nil
}

// SetEx set the value of the key with the given value and expiration in second
func (sc *StringsCacheResp2) SetEx(ctx context.Context, key, val string, expSecond int) error {
	// get conn
	conn, err := sc.pool.GetContext(ctx)
	if err != nil {
		return err
	}
	defer conn.Close()

	// set to redis
	notif, err := sc.cc.NewNotif(sc.name, key).Encode()
	if err != nil {
		return err
	}

	_, err = redis.String(sc.luaSetex.Do(conn, key, expSecond, val, notif))
	if err != nil {
		return err
	}
	sc.setMemCache(key, val, expSecond)
	return nil
}

// Get gets the value of the key.
//
// If the value not exists in the memory cache, it will try to get from the redis server
// and set the expiration to the given expSecond
func (sc *StringsCacheResp2) Get(ctx context.Context, key string, expSecond int) (string, error) {
	// try to get from in memory cache
	val, ok := sc.getMemCache(key)
	if ok {
		return val, nil
	}

	// get from redis
	conn, err := sc.pool.GetContext(ctx)
	if err != nil {
		return "", err
	}
	defer conn.Close()

	val, err = redis.String(conn.Do("GET", key))
	if err != nil {
		if err == redis.ErrNil {
			err = ErrNotFound
		}
		return "", err
	}

	// set to in-mem cache
	sc.setMemCache(key, val, expSecond)

	return val, nil
}

func (sc *StringsCacheResp2) Del(ctx context.Context, key string) error {
	sc.cc.Del(key)

	// get conn
	conn, err := sc.pool.GetContext(ctx)
	if err != nil {
		return err
	}
	defer conn.Close()

	notif, err := sc.cc.NewNotif(sc.name, key).Encode()
	if err != nil {
		return err
	}
	_, err = redis.String(sc.luaDel.Do(conn, key, notif))
	return err
}

func (sc *StringsCacheResp2) setMemCache(key, val string, expSecond int) {
	sc.cc.SetEx(key, val, expSecond)
}

func (sc *StringsCacheResp2) getMemCache(key string) (string, bool) {
	return sc.cc.Get(key)
}

func (sc *StringsCacheResp2) runSubscriber(ctx context.Context) error {
	doneCh, err := sc.startSub()
	if err != nil {
		return err
	}
	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case <-doneCh:
				// we're just disconnected our Notif channel,
				// clear our in mem cache as we can't assume that the values
				// still updated
				sc.cc.Clear()
				doneCh, err = sc.startSub()
				if err != nil {
					log.Printf("failed to start subscriber: %v", err)
				}
			}
		}
	}()
	return nil
}

func (sc *StringsCacheResp2) startSub() (chan struct{}, error) {
	doneCh := make(chan struct{})
	// setup subscriber
	conn := sc.pool.Get()
	if err := conn.Err(); err != nil {
		close(doneCh)
		return doneCh, err
	}
	sub := &redis.PubSubConn{Conn: conn}

	err := sub.Subscribe(stringsnotifChannel)
	if err != nil {
		close(doneCh)
		return doneCh, err
	}

	// we're just connected to our Notif channel,
	// it means we previously not connected or disconnected from the Notif channel.
	// clear our in mem cache as we can't assume that the values
	// still updated
	sc.cc.Clear()

	// run subscriber loop
	go func() {
		defer close(doneCh)
		for {
			switch v := sub.Receive().(type) {
			case redis.Message:
				err := sc.handleNotif(v.Data)
				if err != nil {
					log.Printf("handleNotif failed: %v", err)
					return
				}
			case error:
				log.Printf("subscribe err: %v", v)
				return
			}
		}
	}()
	return doneCh, nil
}

// handleNotif handle raw notification from the redis
func (sc *StringsCacheResp2) handleNotif(data []byte) error {
	// decode notification
	nt, err := notif.Decode(data)
	if err != nil {
		return fmt.Errorf("failed to decode Notif:%w", err)
	}

	// ignore all updated from ourself
	if bytes.Equal(nt.ClientID, sc.name) {
		return nil
	}

	fmt.Printf("[%s]msg from %s, slot:%v\n", sc.name, nt.ClientID, nt.Slot)
	//sc.delMemCache(nt.Key)
	sc.cc.HandleNotif(nt)
	return nil
}

const (
	scriptSetex = `
local setret = redis.call('setex', KEYS[1], ARGV[1], ARGV[2])
redis.call('publish', 'rimcu:strings', ARGV[3])
return 'OK'
			`
	scriptDel = `
local setret = redis.call('del', KEYS[1])
redis.call('publish', 'rimcu:strings', ARGV[1])
return '1'
			`
)

const (
	stringsnotifChannel = "rimcu:strings"
)
